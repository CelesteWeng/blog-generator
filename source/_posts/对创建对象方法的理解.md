---
title: 对创建对象方法的理解
date: 2019-01-24 18:14:05
tags: 
- 创建对象
- 工厂模式
- 构造函数模式
- 原型模式
---

### 1. 创建 Object 对象的实例或通过对象字面量定义。
缺点：大量重复代码。

### 2. 工厂模式
解决了创建 多个相似对象的问题。在函数中定义对象，return 语句返回对象，通过调用函数创建对象。

缺点：书中说是无法识别对象的类型，但实际上创建出的对象变量可通过 constructor 属性判断（person1.constructor === Array），constructor 准确，instanceof 有误差

---

经试验，在函数中通过构造函数创建对象，则对象的 constructor 属性是准确的。
如果是用 `Object 构造函数`创建，只有 obj instanceof Object 为 true；
若是 `Array 构造函数`创建，不仅 
alert(obj instanceof Object); //  true，
同时 
alert(obj instanceof Array); //  true

本人觉得工厂模式，硬是要判断也是可以判断的。
书中的意思：
  - 可能一： 
    直接拿函数来判断，则无法判断函数内定义了哪种对象。
  - 可能二：
    自定义的构造函数创建对象，对象即构造函数的实例，相当于这个对					象的类别就是自定义的构造函数，直观，同时也是 Object 的实例。

### 3. 构造函数模式
相对工厂模式，不显示地创建对象，使用 this 对象，同时没有 return 语句。解决了对象类别的识别问题。

可优化点：将对象的方法定义在全局，避免创建功能相同的 Function 的实例。但是在想要为对象添加很多方法时，就需要在全局声明很多函数，封装性不好。

缺点（将对象的方法声明在全局后，仍存在的问题）：全局函数实际上只能被某个对象调用。

### 4. 原型模式
在函数的 prototype 属性中定义对象的属性和方法，可以被构造函数的实例共用。解决了构造函数模式 将 对象的方法声明在全局后，不能被多个实例共用的问题。